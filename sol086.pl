# The shortest route passes over exactly 2 faces. This is simple to see:
# Upon traversing one face, at least one co-ordinate is changed from 0 to 1.
# We are now coplanar to the final vertex and it's pretty clear that since we
# /can/ now stay in the plane, we /must/.

# Thus there is an initial choice of which of the 3 faces adjacent to our
# corner we traverse first, and a secondary choice of 2 faces for each of these.
# However, note that each of these choices corresponds to "going around the
# other way" with a route based on a different initial choice. Thus, there are
# only 3 routes to consider.

# Assuming an x * y * z cube, and we traverse the face in the z=0 plane first,
# We traverse either a (x+z)*y or x*(y+z) rectangle. The same applies to the
# other two sides; the length of the shortest path is now
# min{sqrt((x+z)^2+y^2), sqrt((x+y)^2+z^2), sqrt((y+z)^2+x^2)}

# Assuming it's a x*(y+z) route, the result is integer if (x, y+z, ...) is a
# Pythagorean triple with x and y+z as the shortest sides. Thus we are to find
# all Pythagorean triples (x, y', z') with x<=M, y'<=2M, compute which
# 2-paritions of y' result in the shortest path being in the expected direction
# and sum all of these.

# Note x^2+(y+z)^2 <= (x+z)^2+y^2 if and only if 2yz <= 2xz ie. y >= x; that is,
# we are looking for the case max{y,z} <= x so in (x, y', ...) we must have
# y' <= 2x for there to be any results. We now just need to count 2-partitions
# of y' such that both numbers are less than or equal to x.

# Duplicates: This method should count all unique sets {x, y, z}. Note the code
# below counts some cases seperately, as originally I assumed that we must
# count duplicates.

# Use Euclid's formula which gives Pythagorean triples for any m >= n.
# a = 2*m*n
# b = m*m - n*n
# c = m*m + n*n
# if m>n are integers, hcf(m, n) = 1 and m + n = 1 mod 2, the above is
# primitive. All triples can be generated by multiples of the above ones.
# Generate all primitives with both short sides less than 10000.
# $triples[$x] is the set of candidate y' for $x, as above.
my @triples;
my $longest = 10000;
my ($m, $n) = (1, 1);
my @c;
while(1) {
	$n++;
	my $a = 2*$m*$n;
	my $b = $m**2 - $n**2;
	if ($a > $longest || $n >= $m) {
		$m++;
		# Set $n so that $m**2 - $n**2 <= $longest
		# That is, $n = sqrt($m**2 - $longest)
		$n = $m ** 2 > $longest ? sqrt($m**2 - $longest) : 1;
		$n = $n == int $n ? $n : int($n) + 1;
		if ($n >= $m) {
			# We can't accomodate any more.
			last;
		}
		$a = 2*$m*$n;
		$b = $m**2 - $n**2;
	}
	next if ($m + $n) % 2 == 0;

	my $i = $m;
	my $j = $n;
	while($j != 0) {
		my $ne = $i % $j;
		$i = $j;
		$j = $ne;
	}
	next if $i != 1;

	my ($short, $middle) = $a > $b ? ($b, $a) : ($a, $b);

	# At this point we have a primitive triple.
	for(1..int($longest/$middle)) {
		$triples[$middle*$_] ||= [];
		push @{$triples[$middle*$_]}, $short*$_;

		# If the short side is too short, ($short, $middle) is unsuitable as a
		# candidate for (x, y').
		next if $short * 2 < $middle;
		$triples[$short*$_] ||= [];
		push @{$triples[$short*$_]}, $middle*$_;
	}
}

# We're now in a position to compute the number of cuboids.
my $total = 0;
my $longest = 0;
while(++$longest) {
	# Note that we already counted those with longest side < $longest, so no
	# need to recompute.
	for my $othersum (@{$triples[$longest]}) {
		if ($othersum == 2 * $x) {
			# x = y = z, so no permutations
			$total++;
		} else {
			# Can have y=z or x=y or x=z (but only one at a time).
			my $diffceil = (2*$longest - $othersum)/2;
			$diffceil = int($diffceil) + 1 if $diffceil != int $diffceil;
			# This is the number of cuboids with sides in strict inc order.
			# (6 perms)
			# Letting longest > b = longest-n > c = othersum-longest+n >= 1
			# $alter is the minimum n, $diffceil is the maximum + 1.
			my $alter = $longest - $othersum + 1;
			$alter = 1 if $alter < 1;
			my $alldifferent = $diffceil - $alter;

			# Number for which exactly one side = the longest. (3 perms)
			my $eqlongest = $longest < $othersum ? 1 : 0;

			# Number for which the two shorter sides are equal. (3 perms)
			my $eqother = $othersum % 2 == 0 ? 1 : 0;
			$total += ($eqother + $eqlongest) + $alldifferent ;
		}
	}
	last if $total > 1000000;
}
print "$longest\n";
